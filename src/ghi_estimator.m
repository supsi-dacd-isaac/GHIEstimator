function [GHI,y_hat] = ghi_estimator(P,GHI_obs,t,location,W,Ta,n_init,opt_pars,k_outlier,err_function,plant_weights)
% Estimate GHI iteratively, starting from a first guess done through a grid
% search. The function take as input the estimated orientations and nominal
% powers of the PV fields that generated the power observations. These
% estimations are provided by means of a coefficient matrix W.
% Inputs: P: T*N matrix of PV plants power observations, where T is the
%             total number of observations and N is the number of PV power
%             plants.
%
%         GHI_obs: ground truth for GHI, taken from a pyranometer. This is
%         for evaluation only, could be empty.
%
%         t: datenum vector relative to the GHI observations
%
%         location: a structure containing the following fields: {'UTC',
%         'latitude','longitude','altitude','n_thetas'}. UTC is a scalar
%         containing the UTC shift in hours, latitude and longitude are
%         floats containing GPS coordinates and altitude is float
%         containing the altitude in meters.
%
%         W: N*N_p matrix where N_p is the number of proxies, containing
%         the identified coefficients for each PV power plant.
%
%         Ta: vector containig ambient temperature observations
%
%         n_init: number of initial search points for the GHI grid search
%
%         opt_pars: struct with fields: {'expWeight','do_plots','lambda',
%                   'max_iter','correction','equally_spaced'}.

%
%         k_outlier: parameter for the interquantile outlier detection.
%
%         err_function: cell array of error function taking as input the
%         sun position (azimuth and elevation) and giving as output the
%         estimated error on the PV signals (mismatch between the
%         observations and the identified PV model). This is used to build
%         the trust function
%
%         plant_weights: optional, only useful in the case in which we
%         possess multiple signals from different inverters for a single PV
%         power plant. For example, suppose we have two PV power plants,
%         each with a single PV field. If we have 3 different inverters for
%         the first PV plant, we can set plant_weights = [1/3 1/3 1/3 1] in
%         order to impute the same importance to the two locations.
% 
% Outputs: GHI: vector of the estimated GHI signal
%
%          y_hat: matrix of the signals generated by the identified PV
%          models under the estimated GHI signal.


if nargin<9
    k_outlier = false;
end

if nargin<10
    err_function = [];
end

if nargin<11
    plant_weights = ones(1,size(P,2));
end

correction = opt_pars.correction;

% Define additional parameters
[sbplt,]=find_plot_layout(size(P,2));
equally_spaced = opt_pars.equally_spaced;
n_obs = size(P,1);
n_pv = size(P,2);

%% Define sun_weigths (the trust function) for the PVs using err_function, 
%  the error functions associated with each PV

if ~isempty(err_function)
    Time = pvl_maketimestruct(t, ones(size(t))*location.UTC); %generate a structured Time
    Location = pvl_makelocationstruct(location.latitude,location.longitude,location.altitude); %Generate a structured Location
    [SunAz, SunEl, ~, ~] = pvl_ephemeris(Time,Location); %compute azimuth, elevation (90ï¿½-zenit) , apparent elevation and solar time. NB:can take additional arguments
    for i=1:size(P,2)
        sun_err(:,i) = err_function{i}(SunAz,SunEl);
    end
    
    if opt_pars.expWeight
        sun_dist = exp(-abs(sun_err));
    else
        sun_dist = min(100/3,1./abs(sun_err));
    end
    
    % If not trust function, sum(sun_weights) = n_pv. 
    % To leave this unchanged, normalize for the sum
    sun_norm = sum(sun_dist,2)/size(P,2);	
    sun_weights = sun_dist./repmat(sun_norm,1,size(P,2));
    
    % plot sun_weights (the trust function) for each PV signal
    res=5;
    ix1=round(SunAz/res)+1;
    ix2=round(SunEl/res)+1;
    
    [X,Y] = meshgrid(0:res:360,0:res:90);
    for i=1:size(P,2)
        filter = SunEl>0 & isfinite(sun_weights(:,i));
        E(:,:,i) = accumarray([ix1(filter),ix2(filter)],sun_weights(filter,i),[360/res+1 90/res+1],@(x) quantile(x,0.05),nan);
        figure;
        [~,h_cb] = imagescwithnan(E(:,:,i)',parula,[1 1 1],X(:),Y(:));
        current_axis =gca;
        current_axis.YDir = 'normal';
        xlabel(h_cb,'Trust function [-]')
        caxis([0,2]);
        xlabel('Sun azimut [deg]')
        ylabel('Sun elevation [deg]')
        title(sprintf('Trust function for PV %i',i))
    end
    drawnow
end

if isempty(err_function)
    weights = plant_weights.*(1/n_pv);
else
    weights = plant_weights.*(1/n_pv).*sun_weights;
end

ghi_max_mult = 1.1;
max_iter = opt_pars.max_iter;
lambda  = repmat(opt_pars.lambda,n_obs,1);
do_plots = opt_pars.do_plots;
if do_plots
    for i=1:3
        h(i) = figure;
    end
end

%% Create matrix of initial GHI evaluations

GHI_clear = ghi_clear_sky(t,location,location.UTC);
GHI_mat = repmat(GHI_clear,1,n_init).*(repmat([linspace(0.001,ghi_max_mult,n_init)],n_obs,1));

%% Find a good starting point for the solution of the non-convex problem

wb=waitbar(0,'grid search...');
for i=1:n_init
    waitbar(i/n_init,wb,sprintf('grid search... (%.0f/%.0f)',i,n_init));
    proxies = compute_proxies(GHI_mat(:,i),t,Ta,location,equally_spaced,correction);
    y_hat = proxies*W;
    err_iter = P - y_hat;
    if isempty(err_function)
        err_grad(:,i) = err_iter*weights';
    else
        err_grad(:,i) = sum(err_iter.*weights,2);
    end
end
close(wb);
[~,col_idx] = min(abs(err_grad),[],2);
abs_ind = sub2ind(size(err_grad),[1:n_obs]',col_idx);
GHI_fg = GHI_mat(abs_ind);
proxies = compute_proxies(GHI_fg,t,Ta,location,equally_spaced,correction);
y_hat = proxies*W;
rrmse = mean(mean(((P -y_hat)).^2).^0.5);
rrmse(2) = rrmse;
GHI = GHI_fg;

%% Backprop from starting point

delta_ghi = 1e-3;               % GHI delta for derivatives computation
is_outlier = false(size(P));   % initialize outliers vector
n_iter=1;                       % initialize and iteration counter
rrmse_tol = 1e-4;               % tolerance on relative RMSE for convergence check
outlier_kickoff = [10,20,30];   % kickoff iterations for outlier detection.

% If iter==outlier_kickoff, the outliers are excluded from the
% optimization process. It is not advisable to perform outlier detection 
% at each iteration for obvious reasons.

while n_iter < max_iter &&  rrmse(n_iter)> rrmse_tol
    
    proxies = compute_proxies(GHI,t,Ta,location,equally_spaced,correction);
    
    % estimate PV power productionand
    y_hat = proxies*W;
    
    % detect outliers
    if k_outlier>0 && any(n_iter==outlier_kickoff)
        is_outlier = detect_outliers(P,y_hat,k_outlier);
    end
    
    % Numerically compute the derivatives of the objective function
    % with respect to the GHI signal
    proxies_up = compute_proxies(GHI+delta_ghi,t,Ta,location,equally_spaced,correction);
    y_hat_up = proxies_up*W;
    y_der = (y_hat_up-y_hat)/delta_ghi;
    err_iter = -(P - y_hat);
    err_iter(is_outlier) = 0;
    err_grad = mean(err_iter.*y_der.*weights,2);
    
    % Perform a gradient descent step
    GHI1 = GHI -err_grad.*lambda;
    
    % exclude non-physical values (keep trak of them and put relative observations to 0)
    do_not_take = (GHI1<0);
    GHI1(GHI1<0) = 0;
    
    % compute again the error
    proxies = compute_proxies(GHI1,t,Ta,location,equally_spaced,correction);
    y_hat_1 = proxies*W;
    err_iter1 = -(P - y_hat_1);
    err_iter1(is_outlier) = 0;
    do_train = mean(abs(err_iter1.*weights)-abs(err_iter.*weights),2)<0;
    
    % Update GHI estimation for those observations whose PV error is
    % decreasing
    GHI(do_train) = GHI1(do_train);
    
    % lambda decay: rescale lambda for those observations whose PV
    % error is non-decreasing
    lambda(~do_train | do_not_take) = lambda(~do_train | do_not_take)*0.9;
    
    GHI(GHI<0) = 0;
    rrmse(n_iter+1) = mean(mean(((P -y_hat)).^2).^0.5);
    
    if ~isempty(GHI_obs)
        score(n_iter) = (mean((GHI-GHI_obs).^2)^0.5)/mean(GHI_obs);
    end
    
    % Plot current solution
    if do_plots
        figure(h(1))
        subplot(2,2,[1,2])
        plot(P);hold on;
        plot(y_hat,'--');
        title(sprintf('mean RRMSE:%0.2e',rrmse(end)))
        for i=1:size(P,2)
            labels{i} = strcat('PV_',num2str(i));   
        end
        labels_2 = labels;
        for i=1:size(P,2)
            labels_2{length(labels_2)+1} = sprintf('PV_{%i,est}',num2str(i));
        end
        legend(labels_2)
        hold off;
        
        subplot 223
        semilogy(rrmse(2:end),'r.','markersize',15);
        title('rrmse')
        subplot 224
        semilogy(score,'r.','markersize',15);
        title('sum of squared errors')
        figure(h(2))
        for i=1:size(P,2)
            subplot(sbplt(1),sbplt(2),i)
            scatter(P(:,i),y_hat(:,i),'.');
        end
        
        figure(h(3))
        plot_idx = 1:min(1000,length(P));
        plot(P(plot_idx,:));hold on;
        plot(y_hat(plot_idx,:),'--');
        plot(GHI(plot_idx));
        labels_3 = labels_2;
        labels_3{length(labels_3)+1} = 'GHI_est';
        legend(labels_3)
        hold off;
        drawnow;
    end
    
    if ~isempty(GHI_obs)
    fprintf('\nIteration %i, RRMSE %0.2e, mean(lambda): %0.2e, RRMSE on ground truth = %0.2e',[n_iter,rrmse(n_iter),mean(lambda), score(end)])
    else
    fprintf('\nIteration %i, RRMSE %0.2e, mean(lambda): %0.2e',[n_iter,rrmse(n_iter),mean(lambda)])    
    end
    fprintf(' Outliers: %i',sum(is_outlier(:)));
    
    n_iter = n_iter +1;
end

end

function is_outlier = detect_outliers(PV,y_hat,k)

n_pv = size(PV,2);
pe = ((y_hat-PV))./PV;
pe_q025 = repmat(quantile(pe,0.25,2),1,n_pv);
pe_q075 = repmat(quantile(pe,0.75,2),1,n_pv);
sample_mean = mean(pe,2)-min(pe,[],2);
sample_median = median(pe,2)-min(pe,[],2);
pe_IQ = pe_q075 - pe_q025;

% if n signals < 5 make k dependent from the mean-median distance
if size(PV,2)<5
    k_ind = abs((sample_mean-sample_median));
    k_ind = k_ind./max([abs(sample_mean),abs(sample_mean)],[],2);
    k = repmat(k,size(pe,1),1).*(1-k_ind/k);
end

% preallocate memory
is_outlier = false(size(pe));
for i=1:size(PV,2)
    is_outlier(:,i) = pe(:,i) < pe_q025(:,i) - k.*pe_IQ(:,i) | pe(:,i) > pe_q075(:,i) + k.*pe_IQ(:,i);
end

end
